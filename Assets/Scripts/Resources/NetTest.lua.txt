local socket = require "socket"
local proto = require "proto"
local sproto = require "sproto"

local host = sproto.new(proto.s2c):host "package"
local request = host:attach(sproto.new(proto.c2s))

local fd

local function send_package(fd, pack)
	local package = string.pack(">s2", pack)
	fd:send(package)
end

local function unpack_package(text)
	local size = #text
	if size < 2 then
		return nil, text
	end
	local s = text:byte(1) * 256 + text:byte(2)
	if size < s+2 then
		return nil, text
	end

	return text:sub(3,2+s), text:sub(3+s)
end

local function recv_package(last)
	local result
	result, last = unpack_package(last)
	if result then
		return result, last
	end
	local s, status, partial = fd:receive(4096)
	local r = s or partial
	if not r or (r == "")then
		return nil, last
	end
	return unpack_package(last .. r)
end

local session = 0

local function send_request(name, args)
	session = session + 1
	local str = request(name, args, session)
	send_package(fd, str)
	print("Request:", session)
end

local last = ""

local function print_request(name, args)
	print("REQUEST", name)
	if args then
		for k,v in pairs(args) do
			print(k,v)
		end
	end
end

local function print_response(session, args)
	print("RESPONSE", session)
	if args then
		for k,v in pairs(args) do
			print(k,v)
		end
	end
end

local function print_package(t, ...)
	if t == "REQUEST" then
		print_request(...)
	else
		assert(t == "RESPONSE")
		print_response(...)
	end
end

local function dispatch_package()
	if not fd then
		return
	end
	while true do
		local v
		v, last = recv_package(last)
		if not v then
			break
		end

		print_package(host:dispatch(v))
	end
end

local INVOKE_TYPE = {}
INVOKE_TYPE.DELAY = 1
INVOKE_TYPE.REPEAT = 2

--注册回调
local invoke_list = {}
function regist(func, time, type)
	local func_data = {func = func, time = time, type = type or INVOKE_TYPE.DELAY, curTime = 0}
	invoke_list[func_data] = func_data
end

function connectCallBack()
	local result, err = fd:connect("192.168.1.102", 8888)
	if err == "already connected" then
		NetState:GetComponent("Text").text = "已连接"
		regist(checkNetState, 5, INVOKE_TYPE.REPEAT)
	elseif err == "timeout" then
		NetState:GetComponent("Text").text = "连接超时"
	elseif err == "Operation already in progress" then
		NetState:GetComponent("Text").text = "连接中"
	end
end

function checkNetState()
	local _, status = fd:send("*l")
	if status == "closed" then
		NetState:GetComponent("Text").text = "连接断开"
	end
end

function start()
	print("lua start...")

	ButtonSend:GetComponent("Button").onClick:AddListener(function()
		send_request("foobar", { what = "BBBB" })
	end)

	ButtonDisconnect:GetComponent("Button").onClick:AddListener(function()
		fd:close()
		NetState:GetComponent("Text").text = "连接断开"
	end)

	ButtonConnect:GetComponent("Button").onClick:AddListener(function()
		fd = socket.tcp()
		fd:settimeout(0)
		fd:connect("192.168.1.102", 8888)
		regist(connectCallBack, 1)	
	end)

	ButtonRecv:GetComponent("Button").onClick:AddListener(function()
		print("44444444444444444444444444444444444444",fd:send("*l"))
	end)

	ButtonTest:GetComponent("Button").onClick:AddListener(function()
		regist(function ( ... )
			print("@@@@@@@@@@@@@@@@@@")
		end, 1, INVOKE_TYPE.REPEAT)
	end)
end

function update()
	dispatch_package()
	doInvoke()
end

function doInvoke()
	for k, v in pairs( invoke_list ) do
		if v.type == INVOKE_TYPE.DELAY then
			v.time = v.time - CS.UnityEngine.Time.deltaTime
			if v.time <= 0 then
				v.func()
				invoke_list[k] = nil
			end
		else
			v.curTime = v.curTime + CS.UnityEngine.Time.deltaTime
			if v.curTime >= v.time then
				v.func()
				v.curTime = 0
			end
		end
	end
end

function ondestroy()
    print("lua destroy")
    if fd then
    	fd:close()
    end
end
