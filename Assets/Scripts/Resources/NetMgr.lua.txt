local socket = require "socket"
local proto = require "proto"
local sproto = require "sproto"

local host = sproto.new(proto.s2c):host "package"
local request = host:attach(sproto.new(proto.c2s))

local fd

local MsgFunc = require( "MsgProcess" )

local function send_package(fd, pack)
	local package = string.pack(">s2", pack)
	fd:send(package)
end

local function unpack_package(text)
	local size = #text
	if size < 2 then
		return nil, text
	end
	local s = text:byte(1) * 256 + text:byte(2)
	if size < s+2 then
		return nil, text
	end

	return text:sub(3,2+s), text:sub(3+s)
end

local function recv_package(last)
	local result
	result, last = unpack_package(last)
	if result then
		return result, last
	end
	local s, status, partial = fd:receive(4096)
	local r = s or partial
	if not r or (r == "")then
		return nil, last
	end
	return unpack_package(last .. r)
end

local session = 0

local cacheSessions = {}
local function send_request(name, args)
	session = session + 1
	local str = request(name, args, session)
	send_package(fd, str)
	-- print("Request:", session)
	cacheSessions[session] = name
end

local last = ""

local function process_request(name, args)
	local func = MsgFunc[name]
	if not func then
		return
	end
	func(args)
end

local function process_response(session, args)
	local name = cacheSessions[session]
	if not name then
		print("ERROR SESSION")
		return
	end
	local func = MsgFunc[name]
	if not func then
		print("NO FUNC FOUND FOR MSG:", name)
		return
	end
	func(args)
	cacheSessions[session] = nil
end

local function process_package(t, ...)
	if t == "REQUEST" then
		process_request(...)
	else
		assert(t == "RESPONSE")
		process_response(...)
	end
end

function connectCallBack()
	local result, err = fd:connect(SERVER_IP, SERVER_PORT)
	if result == 1.0 then
		ObjMgr.getUI("TestUI"):changeStateText("已连接")
	elseif err == "already connected" then
		ObjMgr.getUI("TestUI"):changeStateText("已连接")
	elseif err == "timeout" then
		ObjMgr.getUI("TestUI"):changeStateText("连接超时")
	elseif err == "Operation already in progress" then
		ObjMgr.getUI("TestUI"):changeStateText("连接中")
	end
end

local function dispatch_package()
	if not fd then
		return
	end
	while true do
		local v
		v, last = recv_package(last)
		if not v then
			break
		end

		process_package(host:dispatch(v))
	end
end

-----------------------------------------------------------
local XYObj = require( "XYObj" )
local CurObj = class("CurObj", XYObj)

function CurObj:ctor()
    CurObj.super.ctor(self, "NetMgr")
end

function CurObj:update()
	CurObj.super.update(self)
	dispatch_package()
end

function CurObj:send_request(...)
	send_request(...)
end

function CurObj:disconnect()
	if fd then
    	fd:close()
    end
end

function CurObj:connect()
	fd = socket.tcp()
	fd:settimeout(0)
	fd:connect(SERVER_IP, SERVER_PORT)
	self:invoke(connectCallBack, 1, INVOKE_TYPE.DELAY)	
end

function CurObj:ondestroy()
	self:disconnect()	
end
------------------------------c#中的回调-------------------------------------------------
local curObj
function start()
	curObj = CurObj.new() 
	curObj:registui()
	_G.NetMgr = curObj
end

function update()
	curObj:update()
end

function ondestroy()
	curObj:ondestroy()
end

